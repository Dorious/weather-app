/* tslint:disable */
/* eslint-disable */
/**
 * Locationforecast
 * Weather forecast for a specified place
 *
 * The version of the OpenAPI document: 2.0
 * Contact: weatherapi-adm@met.no
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     * 
     * @type {ForecastMeta}
     * @memberof Forecast
     */
    meta: ForecastMeta;
    /**
     * 
     * @type {Array<ForecastTimeStep>}
     * @memberof Forecast
     */
    timeseries: Array<ForecastTimeStep>;
}
/**
 * 
 * @export
 * @interface ForecastMeta
 */
export interface ForecastMeta {
    /**
     * 
     * @type {ForecastUnits}
     * @memberof ForecastMeta
     */
    units: ForecastUnits;
    /**
     * Update time for this forecast
     * @type {string}
     * @memberof ForecastMeta
     */
    updated_at: string;
}
/**
 * Summary of weather conditions.
 * @export
 * @interface ForecastSummary
 */
export interface ForecastSummary {
    /**
     * 
     * @type {WeatherSymbol}
     * @memberof ForecastSummary
     */
    symbol_code: WeatherSymbol;
}
/**
 * Weather parameters valid for a specific point in time.
 * @export
 * @interface ForecastTimeInstant
 */
export interface ForecastTimeInstant {
    /**
     * Speed of wind
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    wind_speed?: number;
    /**
     * Amount of sky covered by clouds at medium elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction_medium?: number;
    /**
     * Dew point temperature at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    dew_point_temperature?: number;
    /**
     * The directon which moves towards
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    wind_from_direction?: number;
    /**
     * Air pressure at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    air_pressure_at_sea_level?: number;
    /**
     * Amount of sky covered by clouds at low elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction_low?: number;
    /**
     * Air temperature
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    air_temperature?: number;
    /**
     * Amount of sky covered by clouds.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction?: number;
    /**
     * Amount of humidity in the air.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    relative_humidity?: number;
    /**
     * Speed of wind gust
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    wind_speed_of_gust?: number;
    /**
     * Amount of area covered by fog.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    fog_area_fraction?: number;
    /**
     * Amount of sky covered by clouds at high elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction_high?: number;
}
/**
 * Weather parameters valid for a specified time period.
 * @export
 * @interface ForecastTimePeriod
 */
export interface ForecastTimePeriod {
    /**
     * Maximum ultraviolet index if sky is clear
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    ultraviolet_index_clear_sky_max?: number;
    /**
     * Best estimate for amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    precipitation_amount?: number;
    /**
     * Maximum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    precipitation_amount_max?: number;
    /**
     * Minimum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    precipitation_amount_min?: number;
    /**
     * Minimum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    air_temperature_min?: number;
    /**
     * Probability of any precipitation coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    probability_of_precipitation?: number;
    /**
     * Maximum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    air_temperature_max?: number;
    /**
     * Probability of any thunder coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    probability_of_thunder?: number;
}
/**
 * 
 * @export
 * @interface ForecastTimeStep
 */
export interface ForecastTimeStep {
    /**
     * The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601)
     * @type {string}
     * @memberof ForecastTimeStep
     */
    time: string;
    /**
     * 
     * @type {ForecastTimeStepData}
     * @memberof ForecastTimeStep
     */
    data: ForecastTimeStepData;
}
/**
 * Forecast for a specific time
 * @export
 * @interface ForecastTimeStepData
 */
export interface ForecastTimeStepData {
    /**
     * 
     * @type {ForecastTimeStepDataInstant}
     * @memberof ForecastTimeStepData
     */
    instant: ForecastTimeStepDataInstant;
    /**
     * 
     * @type {ForecastTimeStepDataNext12Hours}
     * @memberof ForecastTimeStepData
     */
    next_12_hours?: ForecastTimeStepDataNext12Hours;
    /**
     * 
     * @type {ForecastTimeStepDataNext1Hours}
     * @memberof ForecastTimeStepData
     */
    next_1_hours?: ForecastTimeStepDataNext1Hours;
    /**
     * 
     * @type {ForecastTimeStepDataNext6Hours}
     * @memberof ForecastTimeStepData
     */
    next_6_hours?: ForecastTimeStepDataNext6Hours;
}
/**
 * Parameters which applies to this exact point in time
 * @export
 * @interface ForecastTimeStepDataInstant
 */
export interface ForecastTimeStepDataInstant {
    /**
     * 
     * @type {ForecastTimeInstant}
     * @memberof ForecastTimeStepDataInstant
     */
    details?: ForecastTimeInstant;
}
/**
 * Parameters with validity times over twelve hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext12Hours
 */
export interface ForecastTimeStepDataNext12Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    details: ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    summary: ForecastSummary;
}
/**
 * Parameters with validity times over one hour. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext1Hours
 */
export interface ForecastTimeStepDataNext1Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    details: ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    summary: ForecastSummary;
}
/**
 * Parameters with validity times over six hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext6Hours
 */
export interface ForecastTimeStepDataNext6Hours {
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    summary: ForecastSummary;
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    details: ForecastTimePeriod;
}
/**
 * 
 * @export
 * @interface ForecastUnits
 */
export interface ForecastUnits {
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    air_temperature?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    probability_of_thunder?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    dew_point_temperature?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    wind_from_direction?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    wind_speed?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    precipitation_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction_high?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    precipitation_amount_max?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    air_temperature_max?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    probability_of_precipitation?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    air_pressure_at_sea_level?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction_low?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction_medium?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    ultraviolet_index_clear_sky_max?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    fog_area_fraction?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    precipitation_amount_min?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    wind_speed_of_gust?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    air_temperature_min?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    relative_humidity?: string;
}
/**
 * 
 * @export
 * @interface METJSONForecast
 */
export interface METJSONForecast {
    /**
     * 
     * @type {string}
     * @memberof METJSONForecast
     */
    type: METJSONForecastTypeEnum;
    /**
     * 
     * @type {PointGeometry}
     * @memberof METJSONForecast
     */
    geometry: PointGeometry;
    /**
     * 
     * @type {Forecast}
     * @memberof METJSONForecast
     */
    properties: Forecast;
}

/**
    * @export
    * @enum {string}
    */
export enum METJSONForecastTypeEnum {
    Feature = 'Feature'
}

/**
 * 
 * @export
 * @interface PointGeometry
 */
export interface PointGeometry {
    /**
     * 
     * @type {string}
     * @memberof PointGeometry
     */
    type: PointGeometryTypeEnum;
    /**
     * [longitude, latitude, altitude]. All numbers in decimal.
     * @type {Array<number>}
     * @memberof PointGeometry
     */
    coordinates: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum PointGeometryTypeEnum {
    Point = 'Point'
}

/**
 * A identifier that sums up the weather condition for this time period. May be used with https://api.met.no/weatherapi/weathericon/2.0/.
 * @export
 * @enum {string}
 */
export enum WeatherSymbol {
    ClearskyDay = 'clearsky_day',
    ClearskyNight = 'clearsky_night',
    ClearskyPolartwilight = 'clearsky_polartwilight',
    FairDay = 'fair_day',
    FairNight = 'fair_night',
    FairPolartwilight = 'fair_polartwilight',
    LightssnowshowersandthunderDay = 'lightssnowshowersandthunder_day',
    LightssnowshowersandthunderNight = 'lightssnowshowersandthunder_night',
    LightssnowshowersandthunderPolartwilight = 'lightssnowshowersandthunder_polartwilight',
    LightsnowshowersDay = 'lightsnowshowers_day',
    LightsnowshowersNight = 'lightsnowshowers_night',
    LightsnowshowersPolartwilight = 'lightsnowshowers_polartwilight',
    Heavyrainandthunder = 'heavyrainandthunder',
    Heavysnowandthunder = 'heavysnowandthunder',
    Rainandthunder = 'rainandthunder',
    HeavysleetshowersandthunderDay = 'heavysleetshowersandthunder_day',
    HeavysleetshowersandthunderNight = 'heavysleetshowersandthunder_night',
    HeavysleetshowersandthunderPolartwilight = 'heavysleetshowersandthunder_polartwilight',
    Heavysnow = 'heavysnow',
    HeavyrainshowersDay = 'heavyrainshowers_day',
    HeavyrainshowersNight = 'heavyrainshowers_night',
    HeavyrainshowersPolartwilight = 'heavyrainshowers_polartwilight',
    Lightsleet = 'lightsleet',
    Heavyrain = 'heavyrain',
    LightrainshowersDay = 'lightrainshowers_day',
    LightrainshowersNight = 'lightrainshowers_night',
    LightrainshowersPolartwilight = 'lightrainshowers_polartwilight',
    HeavysleetshowersDay = 'heavysleetshowers_day',
    HeavysleetshowersNight = 'heavysleetshowers_night',
    HeavysleetshowersPolartwilight = 'heavysleetshowers_polartwilight',
    LightsleetshowersDay = 'lightsleetshowers_day',
    LightsleetshowersNight = 'lightsleetshowers_night',
    LightsleetshowersPolartwilight = 'lightsleetshowers_polartwilight',
    Snow = 'snow',
    HeavyrainshowersandthunderDay = 'heavyrainshowersandthunder_day',
    HeavyrainshowersandthunderNight = 'heavyrainshowersandthunder_night',
    HeavyrainshowersandthunderPolartwilight = 'heavyrainshowersandthunder_polartwilight',
    SnowshowersDay = 'snowshowers_day',
    SnowshowersNight = 'snowshowers_night',
    SnowshowersPolartwilight = 'snowshowers_polartwilight',
    Fog = 'fog',
    SnowshowersandthunderDay = 'snowshowersandthunder_day',
    SnowshowersandthunderNight = 'snowshowersandthunder_night',
    SnowshowersandthunderPolartwilight = 'snowshowersandthunder_polartwilight',
    Lightsnowandthunder = 'lightsnowandthunder',
    Heavysleetandthunder = 'heavysleetandthunder',
    Lightrain = 'lightrain',
    RainshowersandthunderDay = 'rainshowersandthunder_day',
    RainshowersandthunderNight = 'rainshowersandthunder_night',
    RainshowersandthunderPolartwilight = 'rainshowersandthunder_polartwilight',
    Rain = 'rain',
    Lightsnow = 'lightsnow',
    LightrainshowersandthunderDay = 'lightrainshowersandthunder_day',
    LightrainshowersandthunderNight = 'lightrainshowersandthunder_night',
    LightrainshowersandthunderPolartwilight = 'lightrainshowersandthunder_polartwilight',
    Heavysleet = 'heavysleet',
    Sleetandthunder = 'sleetandthunder',
    Lightrainandthunder = 'lightrainandthunder',
    Sleet = 'sleet',
    LightssleetshowersandthunderDay = 'lightssleetshowersandthunder_day',
    LightssleetshowersandthunderNight = 'lightssleetshowersandthunder_night',
    LightssleetshowersandthunderPolartwilight = 'lightssleetshowersandthunder_polartwilight',
    Lightsleetandthunder = 'lightsleetandthunder',
    PartlycloudyDay = 'partlycloudy_day',
    PartlycloudyNight = 'partlycloudy_night',
    PartlycloudyPolartwilight = 'partlycloudy_polartwilight',
    SleetshowersandthunderDay = 'sleetshowersandthunder_day',
    SleetshowersandthunderNight = 'sleetshowersandthunder_night',
    SleetshowersandthunderPolartwilight = 'sleetshowersandthunder_polartwilight',
    RainshowersDay = 'rainshowers_day',
    RainshowersNight = 'rainshowers_night',
    RainshowersPolartwilight = 'rainshowers_polartwilight',
    Snowandthunder = 'snowandthunder',
    SleetshowersDay = 'sleetshowers_day',
    SleetshowersNight = 'sleetshowers_night',
    SleetshowersPolartwilight = 'sleetshowers_polartwilight',
    Cloudy = 'cloudy',
    HeavysnowshowersandthunderDay = 'heavysnowshowersandthunder_day',
    HeavysnowshowersandthunderNight = 'heavysnowshowersandthunder_night',
    HeavysnowshowersandthunderPolartwilight = 'heavysnowshowersandthunder_polartwilight',
    HeavysnowshowersDay = 'heavysnowshowers_day',
    HeavysnowshowersNight = 'heavysnowshowers_night',
    HeavysnowshowersPolartwilight = 'heavysnowshowers_polartwilight'
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'xml'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet: async (lat: number, lon: number, format: 'xml', altitude?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('classicFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('classicFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('classicFormatGet', 'format', format)
            const localVarPath = `/classic.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet: async (lat: number, lon: number, altitude?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('classicGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('classicGet', 'lon', lon)
            const localVarPath = `/classic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'json'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet: async (lat: number, lon: number, format: 'json', altitude?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('compactFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('compactFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('compactFormatGet', 'format', format)
            const localVarPath = `/compact.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet: async (lat: number, lon: number, altitude?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('compactGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('compactGet', 'lon', lon)
            const localVarPath = `/compact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'json'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet: async (lat: number, lon: number, format: 'json', altitude?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('completeFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('completeFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('completeFormatGet', 'format', format)
            const localVarPath = `/complete.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet: async (lat: number, lon: number, altitude?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('completeGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('completeGet', 'lon', lon)
            const localVarPath = `/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {'json'} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet: async (format: 'json', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('statusFormatGet', 'format', format)
            const localVarPath = `/status.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'xml'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classicFormatGet(lat: number, lon: number, format: 'xml', altitude?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classicFormatGet(lat, lon, format, altitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classicGet(lat: number, lon: number, altitude?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classicGet(lat, lon, altitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'json'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compactFormatGet(lat: number, lon: number, format: 'json', altitude?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compactFormatGet(lat, lon, format, altitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compactGet(lat: number, lon: number, altitude?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compactGet(lat, lon, altitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'json'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeFormatGet(lat: number, lon: number, format: 'json', altitude?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeFormatGet(lat, lon, format, altitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeGet(lat: number, lon: number, altitude?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeGet(lat, lon, altitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {'json'} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusFormatGet(format: 'json', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusFormatGet(format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'xml'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet(lat: number, lon: number, format: 'xml', altitude?: number, options?: any): AxiosPromise<string> {
            return localVarFp.classicFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<string> {
            return localVarFp.classicGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'json'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet(lat: number, lon: number, format: 'json', altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.compactFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.compactGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {'json'} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet(lat: number, lon: number, format: 'json', altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.completeFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.completeGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {'json'} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet(format: 'json', options?: any): AxiosPromise<string> {
            return localVarFp.statusFormatGet(format, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any): AxiosPromise<string> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {'xml'} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicFormatGet(lat: number, lon: number, format: 'xml', altitude?: number, options?: any) {
        return DataApiFp(this.configuration).classicFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicGet(lat: number, lon: number, altitude?: number, options?: any) {
        return DataApiFp(this.configuration).classicGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {'json'} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactFormatGet(lat: number, lon: number, format: 'json', altitude?: number, options?: any) {
        return DataApiFp(this.configuration).compactFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactGet(lat: number, lon: number, altitude?: number, options?: any) {
        return DataApiFp(this.configuration).compactGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {'json'} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeFormatGet(lat: number, lon: number, format: 'json', altitude?: number, options?: any) {
        return DataApiFp(this.configuration).completeFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeGet(lat: number, lon: number, altitude?: number, options?: any) {
        return DataApiFp(this.configuration).completeGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {'json'} format format code (file extension)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusFormatGet(format: 'json', options?: any) {
        return DataApiFp(this.configuration).statusFormatGet(format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusGet(options?: any) {
        return DataApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthzGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthzGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet(options?: any): AxiosPromise<void> {
            return localVarFp.healthzGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet(options?: any): AxiosPromise<void> {
            return localVarFp.schemaGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * Check health status for product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public healthzGet(options?: any) {
        return MetadataApiFp(this.configuration).healthzGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schema for XML data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public schemaGet(options?: any) {
        return MetadataApiFp(this.configuration).schemaGet(options).then((request) => request(this.axios, this.basePath));
    }
}


